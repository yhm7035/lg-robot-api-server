/// <reference types="node" />
export interface ECDSASignature {
    r: Buffer;
    s: Buffer;
    v: number;
}
export interface Field {
    name: string;
    length?: number;
    allowLess?: boolean;
    allowZero?: boolean;
    default: any;
}
export interface Encrypted {
    iv: string;
    ephemPublicKey: string;
    ciphertext: string;
    mac: string;
}
export interface TransactionBody {
    operation: any;
    nonce: number;
    timestamp: number;
    parent_tx_hash?: string;
}
export interface Account {
    address: string;
    private_key: string;
    public_key: string;
}
export interface KdfParams {
    dklen: number;
    salt: string;
    prf?: string;
    c?: number;
    n?: number;
    r?: number;
    p?: number;
}
export interface V3KeystoreOptions {
    salt?: string;
    iv?: Buffer;
    kdf?: string;
    dklen?: number;
    c?: number;
    n?: number;
    r?: number;
    p?: number;
    prf?: string;
    cipher?: string;
    uuid?: Buffer;
}
export interface V3Keystore {
    version: 3;
    id: string;
    address: string;
    crypto: {
        ciphertext: string;
        cipherparams: {
            iv: string;
        };
        cipher: string;
        kdf: string;
        kdfparams: KdfParams;
        mac: string;
    };
}
/**
 * Adds "0x" to a given `string` if it does not already start with "0x".
 * @param {string} str
 * @returns {string}
 */
export declare const addHexPrefix: (str: string) => string;
/**
 * Converts a `Buffer` into a hex `string`.
 * @param {Buffer} buf
 * @returns {string}
 */
export declare const bufferToHex: (buf: Buffer) => string;
/**
 * Signs a message with a private key and returns a `string` signature.
 * @param {Buffer|Array|string|number} message
 * @param {Buffer} privateKey
 * @param {number} chainId
 * @returns {string}
 */
export declare const ecSignMessage: (message: any, privateKey: Buffer, chainId?: number | undefined) => string;
/**
 * ECDSA public key recovery from signature.
 * @returns Recovered public key
 */
export declare const ecRecoverPub: (msgHash: Buffer, r: Buffer, s: Buffer, v: number, chainId?: number | undefined) => Buffer;
/**
 * Convert signature format of the `eth_sign` RPC method to signature parameters
 */
export declare const ecSplitSig: (signature: Buffer) => ECDSASignature;
/**
 * Checks if the signature is valid.
 * @param {Buffer|Array|string|number} data
 * @param {string} signature signature of the `data`
 * @param {string} address
 * @param {number} chainId
 * @returns {boolean}
 */
export declare const ecVerifySig: (data: any, signature: string, address: string, chainId?: number | undefined) => boolean;
export declare const ecSignTransaction: (txData: TransactionBody, privateKey: Buffer, chainId?: number | undefined) => string;
export declare const hashTransaction: (transaction: string | TransactionBody) => Buffer;
/**
 * Returns the bitcoin's varint encoding of keccak-256 hash of `message`,
 * prefixed with the header 'AINetwork Signed Message:\n'.
 * @param {Buffer|Array|string|number} message
 * @returns {Buffer}
 */
export declare const hashMessage: (message: any) => Buffer;
/**
 * Checks whether the `str` is prefixed with "0x"
 * @param {string} str
 * @return {boolean}
 * @throws if the str input is not a string
 */
export declare const isHexPrefixed: (str: string) => boolean;
/**
 * Checks whether the `privateKey` is a valid private key (follows the rules of
 * the curve secp256k1).
 * @param {Buffer} privateKey
 * @returns {boolean}
 */
export declare const isValidPrivate: (privateKey: Buffer) => boolean;
/**
 * Checks whether the `publicKey` is a valid public key (follows the rules of the
 * curve secp256k1 and meets the AIN requirements).
 * @param {Buffer} publicKey The two points of an uncompressed key, unless sanitize is enabled
 * @param {boolean} isSEC1 Accept public keys in other formats
 * @returns {boolean}
 */
export declare const isValidPublic: (publicKey: Buffer, isSEC1?: boolean) => boolean;
/**
 * Checks if the address is valid.
 * @param {string} address
 * @returns {boolean}
 */
export declare const isValidAddress: (address: string) => boolean;
/**
 * Checks if the two addresses are the same.
 * @param {string} address1
 * @param {string} address2
 * @returns {boolean}
 */
export declare const areSameAddresses: (address1: string, address2: string) => boolean;
/**
 * Creates Keccak hash of the input
 * @param {Buffer|Array|string|number} input
 * @param {number} bits The Keccak width
 * @returns {Buffer}
 */
export declare const keccak: (input: any, bits?: number) => Buffer;
/**
 * Returns the public key of a given private key.
 * @param {Buffer} privateKey A private key must be 256 bits wide
 * @return {Buffer}
 */
export declare const privateToPublic: (privateKey: Buffer) => Buffer;
/**
 * Returns the AI Network address of a given public key.
 * @param {Buffer} publicKey AIN public key | SEC1 encoded public key
 * @param {boolean} isSEC1 Key is SEC1 encoded
 * @returns {Buffer} lower 160 bits of the hash of `publicKey`
 */
export declare const pubToAddress: (publicKey: Buffer, isSEC1?: boolean) => Buffer;
export declare const privateToAddress: (privateKey: Buffer) => string;
/**
 * Returns an Account with the given private key.
 * @param {Buffer} privateKey
 * @return {Account}
 */
export declare const privateToAccount: (privateKey: Buffer) => Account;
/**
 * Serialize an object (e.g. tx data) using rlp encoding.
 * @param {string|Buffer|Array|Object} data
 * @param {Array<Field>} _fields
 * @returns {Buffer}
 * @throws if the data is invalid or the number of fields doesn't match
 */
export declare const serialize: (data: any, _fields?: Field[] | undefined) => Buffer;
/**
 * Pads and `message` with leading zeros till it has `length` bytes.
 * Truncates from the beginning if `message` is longer than `length`.
 * @param {Buffer|Array} message
 * @param {number} length the number of bytes the output should be
 * @param {boolean} right whether to start padding form the left or right
 * @return {Buffer|Array}
 */
export declare const setLength: (message: any, length: number, right?: boolean) => Buffer;
/**
 * Removes '0x' from a given `String` is present
 * @param {string} str the string value
 * @return {string}
 */
export declare const stripHexPrefix: (str: string) => string;
/**
 * Attempts to turn a value into a `Buffer`. As input it supports `Buffer`,
 * `String`, `Number`, null/undefined, `BN` and other objects with a
 * `toArray()` method.
 * @param {Buffer|Array|string|number} v
 * @returns {Buffer}
 */
export declare const toBuffer: (v: any) => Buffer;
/**
 * Returns a checksummed address.
 * @param {string} address
 * @returns {string}
 */
export declare const toChecksumAddress: (address: string) => string;
/**
 * Encrypt message with publicKey.
 * @param {string} publicKey
 * @param {string} message
 * @returns {Encrypted}
 */
export declare const encryptWithPublicKey: (publicKey: string, message: string) => Promise<Encrypted>;
/**
 * Decrypt encrypted data with privateKey
 * @param {string} privateKey
 * @param {string} encrypted
 * @returns {string}
 */
export declare const decryptWithPrivateKey: (privateKey: string, encrypted: string | Encrypted) => Promise<string>;
/**
 * Creates an account with a given entropy
 * @param {string} entropy
 * @return {Account}
 */
export declare const createAccount: (entropy?: string | undefined) => Account;
/**
 * Converts an account into a V3 Keystore and encrypts it with a password
 * @param {Buffer} privateKey
 * @param {string} password
 * @param {V3KeystoreOptions} options
 * @return {V3Keystore}
 */
export declare const privateToV3Keystore: (privateKey: Buffer, password: string, options?: V3KeystoreOptions) => V3Keystore;
/**
 * Returns a private key from a V3 Keystore.
 * @param {V3Keystore | string} v3Keystore
 * @param {string} password
 * @return {Buffer}
 */
export declare const v3KeystoreToPrivate: (v3Keystore: string | V3Keystore, password: string) => Buffer;
export declare function encode(key: string): string;
export declare function decode(key: string): string;
