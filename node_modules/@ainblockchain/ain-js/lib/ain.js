"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var AinUtil = require("@ainblockchain/ain-util");
var provider_1 = require("./provider");
var db_1 = require("./ain-db/db");
var ref_1 = require("./ain-db/ref");
var wallet_1 = require("./wallet");
var net_1 = require("./net");
var Ain = /** @class */ (function () {
    /**
     * @param {string} providerUrl
     * @constructor
     */
    function Ain(providerUrl) {
        this.provider = new provider_1.default(this, providerUrl);
        this.net = new net_1.default(this.provider);
        this.wallet = new wallet_1.default(this);
        this.db = new db_1.default(this, this.provider);
    }
    /**
     * Sets a new provider
     * @param {string} providerUrl
     */
    Ain.prototype.setProvider = function (providerUrl) {
        this.provider = new provider_1.default(this, providerUrl);
        this.db = new db_1.default(this, this.provider);
        this.net = new net_1.default(this.provider);
    };
    /**
     * A promise returns a block with the given hash or block number.
     * @param {string | number} blockHashOrBlockNumber
     * @param {boolean} returnTransactionObjects - If true, returns the full transaction objects;
     * otherwise, returns only the transaction hashes
     * @return {Promise<Block>}
     */
    Ain.prototype.getBlock = function (blockHashOrBlockNumber, returnTransactionObjects) {
        var _a;
        var byHash = typeof blockHashOrBlockNumber === 'string';
        var rpcMethod = byHash ? 'ain_getBlockByHash' : 'ain_getBlockByNumber';
        var data = Object.assign({}, (_a = { getFullTransactions: !!returnTransactionObjects }, _a[byHash ? 'hash' : 'number'] = blockHashOrBlockNumber, _a));
        return this.provider.send(rpcMethod, data);
    };
    /**
     * A promise returns the address of the forger of given block
     * @param {string | number} blockHashOrBlockNumber
     * @return {Promise<string>}
     */
    Ain.prototype.getProposer = function (blockHashOrBlockNumber) {
        var _a;
        var byHash = typeof blockHashOrBlockNumber === 'string';
        var rpcMethod = byHash ? 'ain_getProposerByHash' : 'ain_getProposerByNumber';
        return this.provider.send(rpcMethod, (_a = {}, _a[byHash ? 'hash' : 'number'] = blockHashOrBlockNumber, _a));
    };
    /**
     * A promise returns the list of validators for a given block
     * @param {string | number} blockHashOrBlockNumber
     * @return {Promise<string[]>}
     */
    Ain.prototype.getValidators = function (blockHashOrBlockNumber) {
        var _a;
        var byHash = typeof blockHashOrBlockNumber === 'string';
        var rpcMethod = byHash ? 'ain_getValidatorsByHash' : 'ain_getValidatorsByNumber';
        return this.provider.send(rpcMethod, (_a = {}, _a[byHash ? 'hash' : 'number'] = blockHashOrBlockNumber, _a));
    };
    /**
     * Returns the transaction with the given transaaction hash.
     * @param {string} transactionHash
     * @return {Promise<Transaction>}
     */
    Ain.prototype.getTransaction = function (transactionHash) {
        return this.provider.send('ain_getTransactionByHash', { hash: transactionHash });
    };
    /**
     * Returns the result of the transaction with the given transaaction hash.
     * @param {string} transactionHash
     * @return {Promise<Transaction>}
     */
    // TODO (lia): implement this function
    // getTransactionResult(transactionHash: string): Promise<TransactionResult> {}
    /**
     * Signs and sends a transaction to the network
     * @param {TransactionInput} transactionObject
     * @return {Promise<any>}
     */
    Ain.prototype.sendTransaction = function (transactionObject) {
        return __awaiter(this, void 0, void 0, function () {
            var txBody, signature, txHash, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.buildTransactionBody(transactionObject)];
                    case 1:
                        txBody = _a.sent();
                        signature = this.wallet.signTransaction(txBody, transactionObject.address);
                        txHash = this.wallet.getHashStrFromSig(signature);
                        return [4 /*yield*/, this.provider.send('ain_sendSignedTransaction', { signature: signature, transaction: txBody })];
                    case 2:
                        result = _a.sent();
                        if (!result || typeof result !== 'object') {
                            result = { result: result };
                        }
                        return [2 /*return*/, Object.assign(result, { txHash: txHash })];
                }
            });
        });
    };
    /**
     * Sends a signed transaction to the network
     * @param {string} signature
     * @param {TransactionBody} transaction
     * @return {Promise<any>}
     */
    Ain.prototype.sendSignedTransaction = function (signature, transaction) {
        return __awaiter(this, void 0, void 0, function () {
            var txHash, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        txHash = this.wallet.getHashStrFromSig(signature);
                        return [4 /*yield*/, this.provider.send('ain_sendSignedTransaction', { signature: signature, transaction: transaction })];
                    case 1:
                        result = _a.sent();
                        if (!result || typeof result !== 'object') {
                            result = { result: result };
                        }
                        return [2 /*return*/, Object.assign(result, { txHash: txHash })];
                }
            });
        });
    };
    Ain.prototype.sendTransactionBatch = function (transactionObjects) {
        return __awaiter(this, void 0, void 0, function () {
            var promises, _loop_1, this_1, _i, transactionObjects_1, tx;
            var _this = this;
            return __generator(this, function (_a) {
                promises = [];
                _loop_1 = function (tx) {
                    promises.push(this_1.buildTransactionBody(tx).then(function (txBody) {
                        if (tx.nonce === undefined) {
                            // Batch transactions' nonces should be specified.
                            // If they're not, they default to un-nonced (nonce = -1).
                            txBody.nonce = -1;
                        }
                        var signature = _this.wallet.signTransaction(txBody, tx.address);
                        return { signature: signature, transaction: txBody };
                    }));
                };
                this_1 = this;
                for (_i = 0, transactionObjects_1 = transactionObjects; _i < transactionObjects_1.length; _i++) {
                    tx = transactionObjects_1[_i];
                    _loop_1(tx);
                }
                return [2 /*return*/, Promise.all(promises).then(function (tx_list) { return __awaiter(_this, void 0, void 0, function () {
                        var resultList, len, i;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.provider.send('ain_sendSignedTransaction', { tx_list: tx_list })];
                                case 1:
                                    resultList = _a.sent();
                                    if (!Array.isArray(resultList)) {
                                        return [2 /*return*/, resultList];
                                    }
                                    len = resultList.length;
                                    if (len !== tx_list.length) {
                                        return [2 /*return*/, resultList];
                                    }
                                    else {
                                        for (i = 0; i < len; i++) {
                                            if (!resultList[i] || typeof resultList[i] !== 'object') {
                                                resultList[i] = { result: resultList[i] };
                                            }
                                            resultList[i]['txHash'] = this.wallet.getHashStrFromSig(tx_list[i].signature);
                                        }
                                        return [2 /*return*/, resultList];
                                    }
                                    return [2 /*return*/];
                            }
                        });
                    }); })];
            });
        });
    };
    /**
     * Sends a transaction that deposits AIN for consensus staking.
     * @param {ValueOnlyTransactionInput} transactionObject
     * @return {Promise<any>}
     */
    Ain.prototype.depositConsensusStake = function (transactionObject) {
        return this.stakeFunction('/deposit/consensus', transactionObject);
    };
    /**
     * Sends a transaction that withdraws AIN for consensus staking.
     * @param {ValueOnlyTransactionInput} transactionObject
     * @return {Promise<any>}
     */
    Ain.prototype.withdrawConsensusStake = function (transactionObject) {
        return this.stakeFunction('/withdraw/consensus', transactionObject);
    };
    /**
     * Gets the amount of AIN currently staked for participating in consensus protocol.
     * @param {string} account - If not specified, will try to use the defaultAccount value.
     * @return {Promise<number>}
     */
    Ain.prototype.getConsensusStakeAmount = function (account) {
        var address = account ? Ain.utils.toChecksumAddress(account)
            : this.wallet.getImpliedAddress(account);
        return this.db.ref("/deposit_accounts/consensus/" + address).getValue();
    };
    /**
     * Returns the current transaction count of account, which is the nonce of the account.
     * @param {object} args - May contain a string 'address' and a string 'from' values.
     *                        The 'address' indicates the address of the account to get the
     *                        nonce of, and the 'from' indicates where to get the nonce from.
     *                        It could be either the pending transaction pool ("pending") or
     *                        the committed blocks ("committed"). The default value is "committed".
     * @return {Promise<number>}
     */
    Ain.prototype.getNonce = function (args) {
        if (!args) {
            args = {};
        }
        var address = args.address ? Ain.utils.toChecksumAddress(args.address)
            : this.wallet.getImpliedAddress(args.address);
        if (args.from !== undefined && args.from !== 'pending' && args.from !== 'committed') {
            throw Error("'from' should be either 'pending' or 'committed'");
        }
        return this.provider.send('ain_getNonce', { address: address, from: args.from });
    };
    /**
     * Builds a transaction body from transaction input.
     * @param {TransactionInput} transactionInput
     * @return {Promise<TransactionBody>}
     */
    Ain.prototype.buildTransactionBody = function (transactionInput) {
        return __awaiter(this, void 0, void 0, function () {
            var address, tx, nonce, timestamp;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        address = this.wallet.getImpliedAddress(transactionInput.address);
                        tx = {
                            operation: transactionInput.operation,
                            parent_tx_hash: transactionInput.parent_tx_hash
                        };
                        nonce = transactionInput.nonce;
                        if (!(nonce === undefined)) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.getNonce({ address: address, from: "pending" })];
                    case 1:
                        nonce = (_a.sent()) + 1;
                        _a.label = 2;
                    case 2:
                        timestamp = transactionInput.timestamp ? transactionInput.timestamp : Date.now();
                        return [2 /*return*/, Object.assign(tx, { nonce: nonce, timestamp: timestamp })];
                }
            });
        });
    };
    Object.defineProperty(Ain, "utils", {
        /**
         * Getter for ain-util library
         */
        get: function () {
            return AinUtil;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Checks whether a given object is an instance of TransactionBody interface.
     * @param {string} account
     * @return {boolean}
     */
    Ain.instanceofTransactionBody = function (object) {
        return object.nonce !== undefined && object.timestamp !== undefined &&
            object.operation !== undefined;
    };
    /**
     * A base function for all staking related database changes. It builds a
     * deposit/withdraw transaction and sends the transaction by calling sendTransaction().
     * @param {string} path
     * @param {ValueOnlyTransactionInput} transactionObject
     * @return {Promise<any>}
     */
    Ain.prototype.stakeFunction = function (path, transactionObject) {
        var type = "SET_VALUE";
        if (!transactionObject.value) {
            throw new Error('[ain-js.stakeFunction] a value should be specified.');
        }
        if (typeof transactionObject.value !== 'number') {
            throw new Error('[ain-js.stakeFunction] value has to be a number.');
        }
        transactionObject.address = this.wallet.getImpliedAddress(transactionObject.address);
        var ref = this.db.ref(path + "/" + transactionObject.address).push();
        if (ref instanceof ref_1.default) {
            var operation = {
                ref: path + "/" + transactionObject.address + "/" + ref.key + "/value",
                value: transactionObject.value,
                type: type
            };
            delete transactionObject.value;
            var txInput = Object.assign({ operation: operation }, { transactionObject: transactionObject });
            return this.sendTransaction(txInput);
        }
        else {
            throw new Error('[ain-js.stakeFunction] Error in Reference push.');
        }
    };
    return Ain;
}());
exports.default = Ain;
//# sourceMappingURL=ain.js.map