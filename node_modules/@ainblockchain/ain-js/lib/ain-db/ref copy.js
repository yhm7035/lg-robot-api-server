"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var push_id_1 = require("./push-id");
var Reference = /** @class */ (function () {
    /**
     * @param {Ain} ain An ain instance.
     * @param {String} path The path in the global state tree.
     * @constructor
     */
    function Reference(ain, path) {
        this.path = Reference.sanitizeRef(path);
        var pathArr = this.path ? this.path.split('/') : [];
        this.key = pathArr.length > 0 ? pathArr[pathArr.length - 1] : null;
        this._ain = ain;
        this._isRootReference = this.path === '/';
        this._listeners = {};
        this._numberOfListeners = 0;
    }
    Object.defineProperty(Reference.prototype, "numberOfListeners", {
        /**
         * A getter for number of listeners.
         * @return {number} The number of listeners.
         */
        get: function () {
            return this._numberOfListeners;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * If value is given, it sets the value at a new child of this.path;
     * otherwise, it creates a key for a new child but doesn't set any values.
     * @param {any} value - A value to set at the path.
     * @return {Promise<any> | Reference} A reference instance of the given path.
     */
    Reference.prototype.push = function (value) {
        var newKey = "/" + push_id_1.PushId.generate();
        var ref = new Reference(this._ain, Reference.extendPath(this.path, newKey));
        if (value !== undefined) {
            return ref.setValue({ value: value });
        }
        return ref;
    };
    /**
     * Returns the value at the path.
     * @param path
     */
    Reference.prototype.getValue = function (input) {
        var req = Reference.buildGetRequest('GET_VALUE', Reference.extendPath(this.path, input.ref), input.is_global);
        return this._ain.provider.send('ain_get', req);
    };
    /**
     * Returns the rule at the path.
     * @param path
     */
    Reference.prototype.getRule = function (input) {
        var req = Reference.buildGetRequest('GET_RULE', Reference.extendPath(this.path, input.ref), input.is_global);
        return this._ain.provider.send('ain_get', req);
    };
    /**
     * Returns the owner config at the path.
     * @param path
     */
    Reference.prototype.getOwner = function (input) {
        var req = Reference.buildGetRequest('GET_OWNER', Reference.extendPath(this.path, input.ref), input.is_global);
        return this._ain.provider.send('ain_get', req);
    };
    /**
     * Returns the function config at the path.
     * @param path
     */
    Reference.prototype.getFunction = function (input) {
        var req = Reference.buildGetRequest('GET_FUNCTION', Reference.extendPath(this.path, input.ref), input.is_global);
        return this._ain.provider.send('ain_get', req);
    };
    /**
     * Returns the value / write rule / owner rule / function hash at multiple paths.
     * @param {Array<GetOperation>} requests - Array of get requests
     * Could be any one from "VALUE", "RULE", "OWNER", "FUNC" or a combination of them as an array.
     * @return {Promise<any>}
     */
    Reference.prototype.get = function (gets) {
        var request = { type: 'GET', op_list: gets };
        for (var i = 0; i < gets.length; i++) {
            request.op_list[i].ref = Reference.extendPath(this.path, gets[i].ref);
        }
        return this._ain.provider.send('ain_get', request);
    };
    /**
     * Deletes a value.
     * @param {ValueOnlyTransactionInput} transactionInput - A transaction input object.
     * Any value given will be overwritten with null.
     * @return {Promise<any>}
     */
    Reference.prototype.deleteValue = function (transactionInput) {
        var txInput = transactionInput || {};
        txInput['value'] = null;
        return this._ain.sendTransaction(Reference.extendSetTransactionInput(txInput, Reference.extendPath(this.path, txInput.ref), "SET_VALUE"));
    };
    /**
     * Sets a function config.
     * @param transactionInput
     */
    Reference.prototype.setFunction = function (transactionInput) {
        return this._ain.sendTransaction(Reference.extendSetTransactionInput(transactionInput, Reference.extendPath(this.path, transactionInput.ref), "SET_FUNCTION"));
    };
    /**
     * Sets the owner rule.
     * @param {ValueOnlyTransactionInput} transactionInput - A transaction input object.
     * @return {Promise<any>}
     */
    Reference.prototype.setOwner = function (transactionInput) {
        return this._ain.sendTransaction(Reference.extendSetTransactionInput(transactionInput, Reference.extendPath(this.path, transactionInput.ref), "SET_OWNER"));
    };
    /**
     * Sets the write rule.
     * @param {ValueOnlyTransactionInput} transactionInput - A transaction input object.
     * @return {Promise<any>}
     */
    Reference.prototype.setRule = function (transactionInput) {
        return this._ain.sendTransaction(Reference.extendSetTransactionInput(transactionInput, Reference.extendPath(this.path, transactionInput.ref), "SET_RULE"));
    };
    /**
     * Sets a value.
     * @param {ValueOnlyTransactionInput} transactionInput - A transaction input object.
     * @return {Promise<any>}
     */
    Reference.prototype.setValue = function (transactionInput) {
        return this._ain.sendTransaction(Reference.extendSetTransactionInput(transactionInput, Reference.extendPath(this.path, transactionInput.ref), "SET_VALUE"));
    };
    /**
     * Increments the value.
     * @param {ValueOnlyTransactionInput} transactionInput - A transaction input object.
     * @return {Promise<any>}
     */
    Reference.prototype.incrementValue = function (transactionInput) {
        return this._ain.sendTransaction(Reference.extendSetTransactionInput(transactionInput, Reference.extendPath(this.path, transactionInput.ref), "INC_VALUE"));
    };
    /**
     * Decrements the value.
     * @param {ValueOnlyTransactionInput} transactionInput - A transaction input object.
     * @return {Promise<any>}
     */
    Reference.prototype.decrementValue = function (transactionInput) {
        return this._ain.sendTransaction(Reference.extendSetTransactionInput(transactionInput, Reference.extendPath(this.path, transactionInput.ref), "DEC_VALUE"));
    };
    /**
     * Processes multiple set operations.
     * @param {SetMultiTransactionInput} transactionInput - A transaction input object.
     * @return {Promise<any>}
     */
    Reference.prototype.set = function (transactionInput) {
        return this._ain.sendTransaction(Reference.extendSetMultiTransactionInput(transactionInput, this.path));
    };
    /**
     * Returns the rule evaluation result. True if the params satisfy the write rule,
     * false if not.
     * @param params
     */
    Reference.prototype.evalRule = function (params) {
        var address = this._ain.wallet.getImpliedAddress(params.address);
        var request = {
            address: address,
            ref: Reference.extendPath(this.path, params.ref),
            value: params.value,
            timestamp: params.timestamp
        };
        return this._ain.provider.send('ain_evalRule', request);
    };
    /**
     * Returns the owner evaluation result.
     * @param params
     */
    Reference.prototype.evalOwner = function (params) {
        var request = {
            address: this._ain.wallet.getImpliedAddress(params.address),
            ref: Reference.extendPath(this.path, params.ref),
            permission: params.permission
        };
        return this._ain.provider.send('ain_evalOwner', request);
    };
    /**
     * Returns the function configs that are related to the input ref.
     * @param params
     */
    Reference.prototype.matchFunction = function (params) {
        var request = {
            ref: Reference.extendPath(this.path, params ? params.ref : undefined)
        };
        return this._ain.provider.send('ain_matchFunction', request);
    };
    /**
     * Returns the rule configs that are related to the input ref.
     * @param params
     */
    Reference.prototype.matchRule = function (params) {
        var request = {
            ref: Reference.extendPath(this.path, params ? params.ref : undefined)
        };
        return this._ain.provider.send('ain_matchRule', request);
    };
    /**
     * Returns the owner configs that are related to the input ref.
     * @param params
     */
    Reference.prototype.matchOwner = function (params) {
        var request = {
            ref: Reference.extendPath(this.path, params ? params.ref : undefined)
        };
        return this._ain.provider.send('ain_matchOwner', request);
    };
    /**
     * TODO (lia): Add this function
     * Attaches an listener for database events.
     * @param {EventType} event - A type of event.
     * @param {Function} callback function to be executed when an event occurs.
     */
    // on(event: EventType, callback: Function) {
    //   if (this._isRootReference) {
    //     throw new Error('[ain-js.Reference.on] Cannot attach an on() listener to a root node');
    //   }
    //   if (!this._listeners[event]) { this._listeners[event] = []; }
    //   this._listeners[event].push(callback);
    //   this._numberOfListeners++;
    //   let count = 0;
    //   const interval = setInterval(() => {
    //     if (count >= 3) clearInterval(interval);
    //     if (!!this._listeners[event]) {
    //       this._listeners[event].forEach(cb => {
    //         cb(10);
    //       });
    //     }
    //     count++;
    //   }, 1000);
    // }
    /**
     * TODO (lia): Add this function
     * Removes a database event listener.
     * @param {EventType} event - A type of event.
     * @param {Function} callback - A callback function to dettach from the event.
     */
    // off(event?: EventType, callback?: Function) {
    //   if (!event && !callback) {
    //     this._listeners = {};
    //     this._numberOfListeners = 0;
    //   } else if (!!event && !callback) {
    //     let len = this._listeners[event].length;
    //     this._listeners[event] = [];
    //     this._numberOfListeners = this._numberOfListeners - len;
    //   } else if (!!event && !!callback) {
    //     if (!!this._listeners[event]) {
    //       let index = this._listeners[event].indexOf(callback);
    //       if (index > -1) {
    //         this._listeners[event].splice(index, 1);
    //         this._numberOfListeners--;
    //       }
    //     }
    //   }
    // }
    /**
     * Returns a get request
     * @param type
     * @param ref
     * @param is_global
     */
    Reference.buildGetRequest = function (type, ref, is_global) {
        return { type: type, ref: Reference.sanitizeRef(ref), is_global: is_global };
    };
    /**
     * Returns a path that is the basePath extended with extension.
     * @param basePath
     * @param extension
     */
    Reference.extendPath = function (basePath, extension) {
        var sanitizedBase = Reference.sanitizeRef(basePath);
        var sanitizedExt = Reference.sanitizeRef(extension);
        if (sanitizedBase === '/') {
            return sanitizedExt;
        }
        if (sanitizedExt === '/') {
            return sanitizedBase;
        }
        return sanitizedBase + sanitizedExt;
    };
    /**
     * Decorates a transaction input with an appropriate type, ref and value.
     * @param {ValueOnlyTransactionInput} input - A transaction input object
     * @param {string} ref - The path at which set operations will take place
     * @param {SetOperationType} type - A type of set operations
     * @return {TransactionInput}
     */
    Reference.extendSetTransactionInput = function (input, ref, type) {
        var operation = { type: type, ref: ref, value: input.value, is_global: input.is_global };
        delete input.value;
        return Object.assign(input, { operation: operation });
    };
    /**
     * Decorates a transaction input with an appropriate type and op_list.
     * @param {SetMultiTransactionInput} input - A transaction input object
     * @param {string} ref - The path at which set operations will take place
     * @param {SetMultiOperationType} type - A type of set operations
     * @return {TransactionInput}
     */
    Reference.extendSetMultiTransactionInput = function (input, ref) {
        var op_list = [];
        input.op_list.forEach(function (op) {
            op_list.push(Object.assign(op, { ref: Reference.extendPath(ref, op.ref) }));
        });
        delete input.op_list;
        var operation = { type: 'SET', op_list: op_list };
        return Object.assign(input, { operation: operation });
    };
    /**
     * Returns a sanitized ref. If should have a slash at the
     * beginning and no slash at the end.
     * @param ref
     */
    Reference.sanitizeRef = function (ref) {
        if (!ref)
            return '/';
        return '/' + ref.split('/').filter(function (key) { return key !== ''; }).join('/');
    };
    return Reference;
}());
exports.default = Reference;
//# sourceMappingURL=ref copy.js.map