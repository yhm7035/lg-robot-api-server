"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ain_1 = require("./ain");
var bip39_1 = require("bip39");
var AIN_HD_DERIVATION_PATH = "m/44'/412'/0'/0/"; /* default wallet address for AIN */
var Wallet = /** @class */ (function () {
    /**
     * @constructor
     */
    function Wallet(ain) {
        this.accounts = {};
        this._length = 0;
        this.ain = ain;
    }
    Object.defineProperty(Wallet.prototype, "length", {
        /**
         * Getter for the number of accounts in the wallet.
         */
        get: function () {
            return this._length;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns the full public key of the given address.
     * @param {string} address
     * @return {string}
     */
    Wallet.prototype.getPublicKey = function (address) {
        var checksummed = ain_1.default.utils.toChecksumAddress(address);
        if (!this.accounts[checksummed])
            return '';
        return this.accounts[checksummed].public_key;
    };
    /**
     * Creates {numberOfAccounts} new accounts and add them to the wallet.
     * @param {number} numberOfAccounts
     */
    Wallet.prototype.create = function (numberOfAccounts) {
        if (numberOfAccounts <= 0)
            throw Error("numberOfAccounts should be greater than 0.");
        // TODO (lia): set maximum limit for numberOfAccounts?
        var newAccounts = [];
        for (var i = 0; i < numberOfAccounts; i++) {
            var account = ain_1.default.utils.createAccount();
            this.accounts[account.address] = account;
            newAccounts.push(account.address);
        }
        this._length = this.accounts ? Object.keys(this.accounts).length : 0;
        return newAccounts;
    };
    /**
     * Returns whether the address has already been added to the wallet.
     * @param {string} address
     * @return {boolean}
     */
    Wallet.prototype.isAdded = function (address) {
        return !!(this.accounts[ain_1.default.utils.toChecksumAddress(address)]);
    };
    /**
     * Adds a new account from the given private key.
     * @param {string} privateKey
     */
    Wallet.prototype.add = function (privateKey) {
        var newAccount = Wallet.fromPrivateKey(Buffer.from(privateKey, 'hex'));
        this.accounts[newAccount.address] = newAccount;
        this._length++;
        return newAccount.address;
    };
    /**
     * Adds an account from a seed phrase. Only the account at the given
     * index (default = 0) will be added.
     * @param {string} seedPhrase
     * @param {number} index
     * @return {string} - The address of the newly added account.
     */
    Wallet.prototype.addFromHDWallet = function (seedPhrase, index) {
        if (index === void 0) { index = 0; }
        if (index < 0) {
            throw new Error('[ain-js.wallet.addFromHDWallet] index should be greater than 0');
        }
        if (!bip39_1.validateMnemonic(seedPhrase)) {
            throw new Error('[ain-js.wallet.addFromHDWallet] Invalid seed phrase');
        }
        var seed = bip39_1.mnemonicToSeedSync(seedPhrase);
        var HDkey = require('hdkey');
        var hdkey = HDkey.fromMasterSeed(seed);
        var path = AIN_HD_DERIVATION_PATH + index;
        var wallet = hdkey.derive(path);
        var address = ain_1.default.utils.toChecksumAddress('0x' +
            ain_1.default.utils.pubToAddress(wallet.publicKey, true).toString('hex'));
        this.accounts[address] = {
            address: address,
            public_key: wallet.publicKey.toString('hex'),
            private_key: wallet.privateKey.toString('hex')
        };
        this._length++;
        return address;
    };
    /**
     * Adds an account from a V3 Keystore.
     * @param {V3Keystore | string} v3Keystore
     * @param {string} [password]
     * @return {string} - The address of the newly added account.
     */
    Wallet.prototype.addFromV3Keystore = function (v3Keystore, password) {
        var privateKey = ain_1.default.utils.v3KeystoreToPrivate(v3Keystore, password);
        this.add(privateKey.toString('hex'));
        return ain_1.default.utils.privateToAddress(privateKey);
    };
    /**
     * Removes an account
     * @param {string} address
     */
    Wallet.prototype.remove = function (address) {
        var accountToRemove = ain_1.default.utils.toChecksumAddress(address);
        delete this.accounts[accountToRemove];
        this._length--;
        if (this.defaultAccount === accountToRemove)
            this.removeDefaultAccount();
    };
    /**
     * Sets the default account as {address}. The account should be already added
     * in the wallet.
     * @param {string} address
     */
    Wallet.prototype.setDefaultAccount = function (address) {
        var checksummed = ain_1.default.utils.toChecksumAddress(address);
        if (!this.accounts[checksummed]) {
            throw new Error('[ain-js.wallet.setDefaultAccount] Add the account first before setting it to defaultAccount.');
        }
        this.defaultAccount = checksummed;
    };
    /**
     * Removes a default account (sets it to null).
     */
    Wallet.prototype.removeDefaultAccount = function () {
        this.defaultAccount = null;
    };
    /**
     * Clears the wallet (remove all account information).
     */
    Wallet.prototype.clear = function () {
        this.accounts = {};
        this._length = 0;
        this.removeDefaultAccount();
    };
    /**
     * Returns the "implied" address. If address is not given,
     * it returns the defaultAccount. It throws an error if
     * an address is not given and defaultAccount is not set, or
     * the specified address is not added to the wallet.
     * @param {string} address
     */
    Wallet.prototype.getImpliedAddress = function (address) {
        if (!address && !this.defaultAccount) {
            throw Error('You need to specify the address or set defaultAccount.');
        }
        var checksummed = ain_1.default.utils.toChecksumAddress(String(address ? address : this.defaultAccount));
        if (!this.accounts[checksummed]) {
            throw Error('The address you specified is not added in your wallet. Try adding it first.');
        }
        return checksummed;
    };
    /**
     * Returns the AIN balance of the address.
     * @param {string} address - Defaults to the defaultAccount.
     */
    Wallet.prototype.getBalance = function (address) {
        var addr = address ? ain_1.default.utils.toChecksumAddress(address)
            : this.getImpliedAddress(address);
        return this.ain.db.ref("/accounts/" + addr + "/balance").getValue();
    };
    /**
     * Sends a transfer transaction to the network.
     * @param input
     */
    Wallet.prototype.transfer = function (input) {
        var address = this.getImpliedAddress(input.from);
        var toAddress = ain_1.default.utils.toChecksumAddress(input.to);
        var transferRef = this.ain.db.ref("/transfer/" + address + "/" + toAddress).push();
        return transferRef.setValue({
            ref: '/value', address: address, value: input.value, nonce: input.nonce
        });
    };
    /**
     * Signs a string data with the private key of the given address. It will use
     * the defaultAccount if an address is not provided.
     * @param {string} data
     * @param {string} address
     * @return {string} - signature
     */
    Wallet.prototype.sign = function (data, address) {
        var addr = this.getImpliedAddress(address);
        return ain_1.default.utils.ecSignMessage(data, Buffer.from(this.accounts[addr].private_key, 'hex'));
    };
    /**
     * Signs a transaction data with the private key of the given address. It will use
     * the defaultAccount if an address is not provided.
     * @param {TransactionBody} data
     * @param {string} address
     * @return {string} - signature
     */
    Wallet.prototype.signTransaction = function (tx, address) {
        var addr = this.getImpliedAddress(address);
        return ain_1.default.utils.ecSignTransaction(tx, Buffer.from(this.accounts[addr].private_key, 'hex'));
    };
    Wallet.prototype.getHashStrFromSig = function (signature) {
        var sigBuffer = ain_1.default.utils.toBuffer(signature);
        var len = sigBuffer.length;
        var lenHash = len - 65;
        var hashedData = sigBuffer.slice(0, lenHash);
        return '0x' + hashedData.toString('hex');
    };
    /**
     * Recovers an address of the account that was used to create the signature.
     * @param {string} signature
     * @return {string} - address
     */
    Wallet.prototype.recover = function (signature) {
        var sigBuffer = ain_1.default.utils.toBuffer(signature);
        var len = sigBuffer.length;
        var lenHash = len - 65;
        var hashedData = sigBuffer.slice(0, lenHash);
        var _a = ain_1.default.utils.ecSplitSig(sigBuffer.slice(lenHash, len)), r = _a.r, s = _a.s, v = _a.v;
        return ain_1.default.utils.toChecksumAddress(ain_1.default.utils.bufferToHex(ain_1.default.utils.pubToAddress(ain_1.default.utils.ecRecoverPub(hashedData, r, s, v).slice(1))));
    };
    /**
     * Verifies if the signature is valid and was signed by the address.
     * @param {any} data
     * @param {string} signature
     * @param {string} address
     * @return {boolean}
     */
    Wallet.prototype.verifySignature = function (data, signature, address) {
        return ain_1.default.utils.ecVerifySig(data, signature, address);
    };
    /**
     * Save the accounts in the wallet as V3 Keystores, locking them with the password.
     * @param {string} password
     * @param {V3KeystoreOptions} options
     * @return {V3Keystore[]}
     */
    Wallet.prototype.toV3Keystore = function (password, options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        var V3KeystoreArr = [];
        if (!this.accounts)
            return V3KeystoreArr;
        Object.keys(this.accounts).forEach(function (address) {
            V3KeystoreArr.push(_this.accountToV3Keystore(address, password, options));
        });
        return V3KeystoreArr;
    };
    /**
     * Converts an account into a V3 Keystore and encrypts it with a password
     * @param {TransactionBody} data
     * @param {string} address
     * @param {string} password
     * @param {V3KeystoreOptions} options
     * @return {V3Keystore}
     */
    Wallet.prototype.accountToV3Keystore = function (address, password, options) {
        if (options === void 0) { options = {}; }
        if (!this.accounts[address]) {
            throw new Error('[ain-js.wallet.accountToV3Keystore] No such address exists in the wallet');
        }
        var privateKey = Buffer.from(this.accounts[address].private_key, 'hex');
        return ain_1.default.utils.privateToV3Keystore(privateKey, password, options);
    };
    /**
     * Imports an account from a private key.
     * @param {Buffer} privateKey
     * @return {Account}
     */
    Wallet.fromPrivateKey = function (privateKey) {
        var publicKey = ain_1.default.utils.privateToPublic(privateKey);
        return {
            address: ain_1.default.utils.toChecksumAddress(ain_1.default.utils.bufferToHex(ain_1.default.utils.pubToAddress(publicKey))),
            private_key: privateKey.toString('hex'),
            public_key: publicKey.toString('hex')
        };
    };
    return Wallet;
}());
exports.default = Wallet;
//# sourceMappingURL=wallet.js.map