"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const nanoid_1 = require("nanoid");
const redis_1 = __importDefault(require("./redis"));
const PodPhasePriority = {
    failed: 1,
    pending: 2,
    createContainer: 3,
    success: 4,
};
function getRandomRequestId() {
    const nanoid = nanoid_1.customAlphabet('abcdefghijklmnopqrstuvwxyz0123456789', 25);
    return nanoid();
}
class Client {
    constructor(options) {
        this.redisClient = new redis_1.default(options);
    }
    sendRequest(type, params) {
        return __awaiter(this, void 0, void 0, function* () {
            const requestId = getRandomRequestId();
            const { clusterName } = params;
            const key = `worker:request_queue:${clusterName}:${requestId}`;
            const responseKey = `worker:response:${clusterName}:${requestId}`;
            // write payload as stringified form
            const value = { type, updatedAt: Date.now(), payload: JSON.stringify(params) };
            const reply = yield this.redisClient.once(key, value, responseKey);
            if (reply.statusCode === "0" /* success */) {
                return {
                    statusCode: "0" /* success */,
                    result: JSON.parse(reply.result),
                    updatedAt: reply.updatedAt,
                };
            }
            return {
                statusCode: reply.statusCode,
                errMessage: reply.errMessage,
                updatedAt: reply.updatedAt,
            };
        });
    }
    unref() {
        this.redisClient.unref();
    }
    /* Deployment */
    deploy(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.sendRequest('deploy', params);
            return res;
        });
    }
    redeploy(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.sendRequest('redeploy', params);
            return res;
        });
    }
    undeploy(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.sendRequest('undeploy', params);
            return res;
        });
    }
    /* Namespace */
    createNamespace(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.sendRequest('createNamespace', params);
            return res;
        });
    }
    deleteNamespace(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.sendRequest('deleteNamespace', params);
            return res;
        });
    }
    /* Storage */
    createStorage(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.sendRequest('createStorage', params);
            return res;
        });
    }
    deleteStorage(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.sendRequest('deleteStorage', params);
            return res;
        });
    }
    /* Secret */
    createSecret(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.sendRequest('createSecret', params);
            return res;
        });
    }
    /* FTP */
    putStorageToFtp(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.sendRequest('putStorageToFtp', params);
            return res;
        });
    }
    getStorageFromFtp(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.sendRequest('getStorageFromFtp', params);
            return res;
        });
    }
    /* Container Log */
    getContainerLog(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.sendRequest('getContainerLog', params);
            return res;
        });
    }
    getClusterList(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const keys = yield this.redisClient.keys('worker:info:*');
            const available = [];
            const scalable = [];
            for (const key of keys) {
                const value = yield this.redisClient.get(key);
                const status = JSON.parse(value.status);
                const targetNodePool = {};
                const scalableNodePool = {};
                const nodePoolNames = Object.keys(status.nodePool);
                for (const nodePoolName of nodePoolNames) {
                    // params.gpu format: {'v100': 1}
                    const targetNode = {};
                    const nodePool = status.nodePool[nodePoolName];
                    let matched = false;
                    if (!params
                        || (!params.gpu && nodePool.gpuType === '')
                        || (params.gpu && params.gpu[nodePool.gpuType] !== undefined)) {
                        matched = true;
                        const nodeIds = Object.keys(nodePool.nodes);
                        for (const nodeId of nodeIds) {
                            const node = nodePool.nodes[nodeId];
                            if (!params
                                || ((!params.gpu || node.allocatable.gpu >= params.gpu[nodePool.gpuType])
                                    && node.allocatable.cpu >= params.cpu
                                    && node.allocatable.memory >= params.memory)) {
                                targetNode[nodeId] = node;
                            }
                        }
                    }
                    if (Object.keys(targetNode).length !== 0) {
                        targetNodePool[nodePoolName] = {
                            cpu: nodePool.cpu,
                            memory: nodePool.memory,
                            gpuType: nodePool.gpuType,
                            osImage: nodePool.osImage,
                            isAutoScaleEnabled: nodePool.isAutoScaleEnabled,
                            nodes: targetNode,
                        };
                    }
                    else if (matched && nodePool.isAutoScaleEnabled
                        && (!params
                            || (nodePool.cpu >= params.cpu
                                && nodePool.memory >= params.memory))) {
                        // no available node, but nodePool is scalable
                        scalableNodePool[nodePoolName] = {
                            cpu: nodePool.cpu,
                            memory: nodePool.memory,
                            gpuType: nodePool.gpuType,
                            osImage: nodePool.osImage,
                            isAutoScaleEnabled: nodePool.isAutoScaleEnabled,
                        };
                    }
                }
                if (Object.keys(targetNodePool).length !== 0) {
                    available.push({
                        updatedAt: value.updatedAt,
                        clusterName: status.clusterName,
                        type: status.type,
                        nodePool: targetNodePool,
                    });
                }
                if (Object.keys(scalableNodePool).length !== 0) {
                    scalable.push({
                        updatedAt: value.updatedAt,
                        clusterName: status.clusterName,
                        type: status.type,
                        nodePool: scalableNodePool,
                    });
                }
            }
            // available first, scalable later
            return [...available, ...scalable];
        });
    }
    getClusterStatus(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const statusPath = `worker:info:${params.clusterName}`;
            const res = yield this.redisClient.get(statusPath);
            /* parse stringified property in setClusterStatus() */
            if (res) {
                res.status = JSON.parse(res.status);
                return res;
            }
            return null;
        });
    }
    getContainerStatus(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const pattern = `container:${params.clusterName}:${params.containerId}:*`;
            const keys = yield this.redisClient.keys(pattern);
            let curStatus = 'failed';
            if (keys.length !== 0) {
                for (const key of keys) {
                    const value = yield this.redisClient.get(key);
                    /* parse stringified property in setPodStatus() */
                    if (value.status) {
                        value.status = JSON.parse(value.status);
                        if (PodPhasePriority[curStatus] < PodPhasePriority[value.status.status.phase]) {
                            curStatus = value.status.status.phase;
                        }
                    }
                }
                return { containerStatus: curStatus };
            }
            return null;
        });
    }
    getStorageStatus(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const statusPath = `storage:${params.clusterName}:${params.storageId}`;
            const res = yield this.redisClient.get(statusPath);
            if (res) {
                res.status = JSON.parse(res.status);
                return res;
            }
            return null;
        });
    }
    createSnapshotFromContainer(params) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.sendRequest('createSnapshotFromContainer', params);
        });
    }
    getSnapshotStatus(params) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.sendRequest('getSnapshotStatus', params);
        });
    }
}
exports.default = Client;
//# sourceMappingURL=client.js.map