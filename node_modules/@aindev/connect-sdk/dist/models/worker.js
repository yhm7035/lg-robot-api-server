"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const wallet_1 = __importDefault(require("./wallet"));
const firebase_1 = __importDefault(require("../common/firebase"));
class Worker {
    constructor(mnemonic, clusterName, env, config) {
        this.wallet = new wallet_1.default(mnemonic, env);
        this.clusterName = clusterName;
        this.firebase = new firebase_1.default(env, config);
    }
    getAddress() {
        return this.wallet.getAddress();
    }
    writeResult(result, dbpath) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = this.wallet.signaturePayload({
                payload: JSON.stringify(Object.assign({ updatedAt: this.firebase.getTimestamp() }, result)),
            });
            const reqMassage = Object.assign(Object.assign({}, data), { dbpath });
            yield this.firebase.getInstance().functions()
                .httpsCallable('sendTransaction')(reqMassage);
        });
    }
    listenRequest(methods) {
        this.listenMethodList = methods;
        this.firebase.getInstance().database()
            .ref(`/worker/request_queue/${this.clusterName}@${this.wallet.getAddress()}`)
            .on('child_added', (data) => __awaiter(this, void 0, void 0, function* () {
            const requestId = data.key;
            const value = data.val();
            const methodType = value.type;
            const dbpath = `/worker/request_queue/${this.clusterName}@${this.wallet.getAddress()}/${requestId}/response`;
            if (value.response) { // already has response
                return;
            }
            if (this.listenMethodList[methodType]) {
                let result;
                try {
                    result = {
                        statusCode: "0" /* success */,
                        result: yield this.listenMethodList[methodType](value.address, value.payload),
                    };
                }
                catch (e) {
                    result = {
                        statusCode: "2" /* failedMethod */,
                        errMessage: String(e),
                    };
                }
                yield this.writeResult(result, dbpath);
            }
            else {
                yield this.writeResult({
                    statusCode: "1" /* invalidParams */,
                    errMessage: `Not defined method: ${methodType}`,
                }, dbpath);
            }
        }));
    }
    deletePath(path) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = this.wallet.signaturePayload({ path });
            yield this.firebase.getInstance().functions()
                .httpsCallable('deleteTransaction')(data);
        });
    }
    writeStatus(status, dbpath) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = this.wallet.signaturePayload({
                payload: JSON.stringify({
                    updatedAt: this.firebase.getTimestamp(),
                    params: status,
                }),
            });
            const reqMassage = Object.assign(Object.assign({}, data), { dbpath });
            yield this.firebase.getInstance().functions()
                .httpsCallable('sendTransaction')(reqMassage);
        });
    }
    setClusterStatus(status) {
        return __awaiter(this, void 0, void 0, function* () {
            const path = `/worker/info/${status.clusterName}@${this.getAddress()}`;
            yield this.writeStatus(Object.assign({ address: this.getAddress() }, status), path);
        });
    }
    deleteClusterStatus(clusterName) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.deletePath(`/worker/info/${clusterName}@${this.getAddress()}`);
        });
    }
    setWorkerStatusForDocker(clusterName) {
        return __awaiter(this, void 0, void 0, function* () {
            const path = `/worker/info/${clusterName}@${this.getAddress()}`;
            yield this.writeStatus({
                address: this.getAddress(),
                clusterName,
                isDocker: true,
            }, path);
        });
    }
    deleteWorkerStatusForDocker(clusterName) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.deletePath(`/worker/info/${clusterName}@${this.getAddress()}`);
        });
    }
    setPodStatus(status) {
        return __awaiter(this, void 0, void 0, function* () {
            const { clusterName, containerId, podId } = status;
            const key = `/container/${clusterName}@${this.getAddress()}/${containerId}/${podId}`;
            yield this.writeStatus(status.podStatus, key);
        });
    }
    deletePodStatus(clusterName, containerId, podId) {
        return __awaiter(this, void 0, void 0, function* () {
            const key = `/container/${clusterName}@${this.getAddress()}/${containerId}/${podId}`;
            yield this.deletePath(key);
        });
    }
    setContainerStatusForDocker(status) {
        return __awaiter(this, void 0, void 0, function* () {
            const { clusterName, containerId } = status;
            const key = `/container/${clusterName}@${this.getAddress()}/${containerId}`;
            yield this.writeStatus(status.containerStatus, key);
        });
    }
    deleteContainerStatusForDocker(clusterName, containerId) {
        return __awaiter(this, void 0, void 0, function* () {
            const key = `/container/${clusterName}@${this.getAddress()}/${containerId}`;
            yield this.deletePath(key);
        });
    }
    setStorageStatus(status) {
        return __awaiter(this, void 0, void 0, function* () {
            const key = `/storage/${status.clusterName}@${this.getAddress()}/${status.storageId}`;
            yield this.writeStatus(status.storageStatus, key);
        });
    }
    deleteStorageStatus(clusterName, storageId) {
        return __awaiter(this, void 0, void 0, function* () {
            const key = `/storage/${clusterName}@${this.getAddress()}/${storageId}`;
            yield this.deletePath(key);
        });
    }
    getAllContainers(clusterName) {
        return __awaiter(this, void 0, void 0, function* () {
            const snap = yield this.firebase.getInstance().database()
                .ref(`/container/${clusterName}@${this.getAddress()}`).once('value');
            if (!snap.exists) {
                return null;
            }
            return snap.val();
        });
    }
    getAllStorages(clusterName) {
        return __awaiter(this, void 0, void 0, function* () {
            const snap = yield this.firebase.getInstance().database()
                .ref(`/storage/${clusterName}@${this.getAddress()}`).once('value');
            if (!snap.exists) {
                return null;
            }
            return snap.val();
        });
    }
    getAllContainersForDocker(clusterName) {
        return __awaiter(this, void 0, void 0, function* () {
            const snap = yield this.firebase.getInstance().database()
                .ref(`/container/${clusterName}@${this.getAddress()}`).once('value');
            if (!snap.exists) {
                return null;
            }
            return snap.val();
        });
    }
}
exports.default = Worker;
//# sourceMappingURL=worker.js.map